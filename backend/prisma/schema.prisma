// schema.prisma

generator client {
  provider = "prisma-client-js"
  output   = "../../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
}

model User {
  id             String       @id @default(uuid())
  email          String       @unique
  username       String       @unique
  googleId       String?      @unique
  password       String?
  name           String?
  image          String?
  role           Role         @default(USER)
  // YouTube subscriptions
  subscriptions  Channel[]    @relation("UserSubscriptions")
  // Named collections
  collections    Collection[] @relation("CollectionOwner")
  // Google tokens
  googleToken    GoogleToken?
  likes          CollectionLike[]
  grantedAccess  CollectionAccess[] @relation("GrantedAccessToUser")
  createdAt      DateTime     @default(now())
}

model Channel {
  id              String     @id @default(uuid())
  youtubeId       String     @unique
  title           String
  thumbnail       String?
  thumbnailUpdatedAt DateTime? // Track when thumbnail was last updated
  subscriberCount Int?
  // Who subscribes
  subscribers     User[]     @relation("UserSubscriptions")
  // Optionally store videos if user picks them
  videos          Video[]
  // Collections this channel is in
  collectionItems CollectionItem[]
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
}

model Video {
  id             String    @id @default(uuid())
  youtubeId      String    @unique
  title          String
  thumbnail      String?
  publishedAt    DateTime?
  // Reference to parent channel
  channel        Channel   @relation(fields: [channelId], references: [id])
  channelId      String
  // Collections this video is in
  collectionItems CollectionItem[]
  createdAt      DateTime  @default(now())
}

model Collection {
  id             String           @id @default(uuid())
  // Unique per user
  slug           String           
  name           String
  description    String?
  // Single note for the entire collection
  note           String?
  isPublic       Boolean          @default(true)
  // Owner
  owner          User             @relation("CollectionOwner", fields: [userId], references: [id])
  userId         String
  // Items: either a channel or a specific video
  items          CollectionItem[]
  likes          CollectionLike[]
  accessGrants   CollectionAccess[] @relation("GrantedAccessToCollection")
  createdAt      DateTime         @default(now())

  @@unique([userId, slug])
}

model CollectionItem {
  id             String      @id @default(uuid())
  // Parent collection
  collection     Collection  @relation(fields: [collectionId], references: [id])
  collectionId   String
  // Either channelId or videoId is set
  channel        Channel?    @relation(fields: [channelId], references: [id])
  channelId      String?
  video          Video?      @relation(fields: [videoId], references: [id])
  videoId        String?
  createdAt      DateTime    @default(now())
}

// Store Google tokens for authenticated users
model GoogleToken {
  id             String   @id @default(uuid())
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String   @unique
  accessToken    String   @db.Text // Use Text for potentially long tokens
  refreshToken   String   @db.Text // Use Text for potentially long tokens
  expiryDate     DateTime
  scope          String?  // Add scope field (optional)
  tokenType      String?  // Add token_type field (optional)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

// --- Add CollectionLike model ---
model CollectionLike {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  // Relation to User who liked
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade) 
  userId String

  // Relation to Collection that was liked
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade) 
  collectionId String

  // Ensure a user can only like a specific collection once
  @@unique([userId, collectionId])
}

// --- Add CollectionAccess model ---
model CollectionAccess {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  // The user who is granted access
  grantedToUser   User   @relation("GrantedAccessToUser", fields: [grantedToUserId], references: [id], onDelete: Cascade) 
  grantedToUserId String

  // The collection access is granted to
  collection   Collection @relation("GrantedAccessToCollection", fields: [collectionId], references: [id], onDelete: Cascade) 
  collectionId String

  // Ensure a user only gets access granted once per collection
  @@unique([grantedToUserId, collectionId])
}
